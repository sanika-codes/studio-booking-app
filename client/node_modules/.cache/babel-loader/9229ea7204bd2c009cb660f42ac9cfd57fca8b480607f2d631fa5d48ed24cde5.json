{"ast":null,"code":"\"use strict\";\n\n// Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Endpoint = void 0;\nconst apirequest_1 = require(\"./apirequest\");\nclass Endpoint {\n  constructor(options) {\n    this._options = options || {};\n  }\n  /**\n   * Given a schema, add methods and resources to a target.\n   *\n   * @param {object} target The target to which to apply the schema.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods and\n   * resources.\n   * @param {object} context The context to add to each method.\n   */\n  applySchema(target, rootSchema, schema, context) {\n    this.applyMethodsFromSchema(target, rootSchema, schema, context);\n    if (schema.resources) {\n      for (const resourceName in schema.resources) {\n        if (Object.prototype.hasOwnProperty.call(schema.resources, resourceName)) {\n          const resource = schema.resources[resourceName];\n          if (!target[resourceName]) {\n            target[resourceName] = {};\n          }\n          this.applySchema(target[resourceName], rootSchema, resource, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a schema, add methods to a target.\n   *\n   * @param {object} target The target to which to apply the methods.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods.\n   * @param {object} context The context to add to each method.\n   */\n  applyMethodsFromSchema(target, rootSchema, schema, context) {\n    if (schema.methods) {\n      for (const name in schema.methods) {\n        if (Object.prototype.hasOwnProperty.call(schema.methods, name)) {\n          const method = schema.methods[name];\n          target[name] = this.makeMethod(rootSchema, method, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a method schema, add a method to a target.\n   *\n   * @param target The target to which to add the method.\n   * @param schema The top-level schema that contains the rootUrl, etc.\n   * @param method The method schema from which to generate the method.\n   * @param context The context to add to the method.\n   */\n  makeMethod(schema, method, context) {\n    return (paramsOrCallback, callback) => {\n      const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n      callback = typeof paramsOrCallback === 'function' ? paramsOrCallback : callback;\n      const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n      const parameters = {\n        options: {\n          url: schemaUrl.substring(1, schemaUrl.length - 1),\n          method: method.httpMethod\n        },\n        params,\n        requiredParams: method.parameterOrder || [],\n        pathParams: this.getPathParams(method.parameters),\n        context\n      };\n      if (method.mediaUpload && method.mediaUpload.protocols && method.mediaUpload.protocols.simple && method.mediaUpload.protocols.simple.path) {\n        const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n        parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n      }\n      if (!callback) {\n        return (0, apirequest_1.createAPIRequest)(parameters);\n      }\n      (0, apirequest_1.createAPIRequest)(parameters, callback);\n      return;\n    };\n  }\n  getPathParams(params) {\n    const pathParams = new Array();\n    if (typeof params !== 'object') {\n      params = {};\n    }\n    Object.keys(params).forEach(key => {\n      if (params[key].location === 'path') {\n        pathParams.push(key);\n      }\n    });\n    return pathParams;\n  }\n}\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\nfunction buildurl(input) {\n  return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Endpoint","apirequest_1","require","constructor","options","_options","applySchema","target","rootSchema","schema","context","applyMethodsFromSchema","resources","resourceName","prototype","hasOwnProperty","call","resource","methods","name","method","makeMethod","paramsOrCallback","callback","params","schemaUrl","buildurl","rootUrl","servicePath","path","parameters","url","substring","length","httpMethod","requiredParams","parameterOrder","pathParams","getPathParams","mediaUpload","protocols","simple","mediaUrl","createAPIRequest","Array","keys","forEach","key","location","push","input","replace"],"sources":["D:/Amber Horizons/Clients/Vibini Creates/node_modules/googleapis-common/build/src/endpoint.js"],"sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Endpoint = void 0;\nconst apirequest_1 = require(\"./apirequest\");\nclass Endpoint {\n    constructor(options) {\n        this._options = options || {};\n    }\n    /**\n     * Given a schema, add methods and resources to a target.\n     *\n     * @param {object} target The target to which to apply the schema.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods and\n     * resources.\n     * @param {object} context The context to add to each method.\n     */\n    applySchema(target, rootSchema, schema, context) {\n        this.applyMethodsFromSchema(target, rootSchema, schema, context);\n        if (schema.resources) {\n            for (const resourceName in schema.resources) {\n                if (Object.prototype.hasOwnProperty.call(schema.resources, resourceName)) {\n                    const resource = schema.resources[resourceName];\n                    if (!target[resourceName]) {\n                        target[resourceName] = {};\n                    }\n                    this.applySchema(target[resourceName], rootSchema, resource, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a schema, add methods to a target.\n     *\n     * @param {object} target The target to which to apply the methods.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods.\n     * @param {object} context The context to add to each method.\n     */\n    applyMethodsFromSchema(target, rootSchema, schema, context) {\n        if (schema.methods) {\n            for (const name in schema.methods) {\n                if (Object.prototype.hasOwnProperty.call(schema.methods, name)) {\n                    const method = schema.methods[name];\n                    target[name] = this.makeMethod(rootSchema, method, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a method schema, add a method to a target.\n     *\n     * @param target The target to which to add the method.\n     * @param schema The top-level schema that contains the rootUrl, etc.\n     * @param method The method schema from which to generate the method.\n     * @param context The context to add to the method.\n     */\n    makeMethod(schema, method, context) {\n        return (paramsOrCallback, callback) => {\n            const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n            callback =\n                typeof paramsOrCallback === 'function'\n                    ? paramsOrCallback\n                    : callback;\n            const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n            const parameters = {\n                options: {\n                    url: schemaUrl.substring(1, schemaUrl.length - 1),\n                    method: method.httpMethod,\n                },\n                params,\n                requiredParams: method.parameterOrder || [],\n                pathParams: this.getPathParams(method.parameters),\n                context,\n            };\n            if (method.mediaUpload &&\n                method.mediaUpload.protocols &&\n                method.mediaUpload.protocols.simple &&\n                method.mediaUpload.protocols.simple.path) {\n                const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n                parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n            }\n            if (!callback) {\n                return (0, apirequest_1.createAPIRequest)(parameters);\n            }\n            (0, apirequest_1.createAPIRequest)(parameters, callback);\n            return;\n        };\n    }\n    getPathParams(params) {\n        const pathParams = new Array();\n        if (typeof params !== 'object') {\n            params = {};\n        }\n        Object.keys(params).forEach(key => {\n            if (params[key].location === 'path') {\n                pathParams.push(key);\n            }\n        });\n        return pathParams;\n    }\n}\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\nfunction buildurl(input) {\n    return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}\n//# sourceMappingURL=endpoint.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}